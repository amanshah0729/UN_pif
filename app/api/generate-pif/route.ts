import { openai } from '@ai-sdk/openai';
import { generateText } from 'ai';
import { getCountryByName } from '@/lib/countries';
import { supabase } from '@/lib/supabaseClient';
import { extractText } from 'unpdf';
import fs from 'fs';
import path from 'path';
import { jsonrepair } from 'jsonrepair';

// Section names mapping (matching the 10 PIF sections)
const SECTION_NAMES = [
  'GHG Inventory',
  'Climate Transparency',
  'Adaptation and Vulnerability',
  'NDC Tracking',
  'Institutional Framework for Climate Action',
  'National Policy Framework',
  'Support Needed and Received',
  'Key Barriers',
  'Other Baseline Initiatives',
  'Official Reporting to the UNFCCC'
];


// Helper function to format section content for template replacement
function formatSectionContent(content: unknown): string {
  if (!content) return '';
  if (typeof content === 'string') return content;
  if (Array.isArray(content)) {
    return content.map(item => formatSectionContent(item)).join('\n\n');
  }
  if (typeof content === 'object') {
    // Handle documents array structure
    if ('documents' in content && Array.isArray((content as any).documents)) {
      return (content as any).documents
        .map((doc: any) => doc.extracted_text || '')
        .filter((text: string) => text.trim().length > 0)
        .join('\n\n---\n\n');
    }
    return JSON.stringify(content, null, 2);
  }
  return String(content);
}

// Pre-computed section boundaries (start and end indices in template content array)
// These were generated by analyzing the template structure - each section is extracted independently
const SECTION_BOUNDARIES: Record<string, { start: number; end: number }> = {
  'Climate Transparency': { start: 15, end: 24 },
  'Institutional Framework for Climate Action': { start: 31, end: 36 },
  'National Policy Framework': { start: 36, end: 47 },
  'Official Reporting to the UNFCCC': { start: 47, end: 58 },
  'GHG Inventory': { start: 58, end: 70 },
  'Adaptation and Vulnerability': { start: 70, end: 83 },
  'NDC Tracking': { start: 83, end: 95 },
  'Support Needed and Received': { start: 95, end: 106 },
  'Other Baseline Initiatives': { start: 106, end: 111 },
  'Key Barriers': { start: 111, end: 131 },
};

// Extract section JSON chunk from template using pre-computed boundaries
function extractSectionJSON(templateContent: any[], sectionName: string): { startIndex: number; endIndex: number; sectionJSON: any[] } | null {
  const boundaries = SECTION_BOUNDARIES[sectionName];
  
  if (!boundaries || !templateContent) {
    console.warn(`No boundaries found for section: ${sectionName}`);
    return null;
  }

  const { start, end } = boundaries;
  
  // Validate indices
  if (start < 0 || end > templateContent.length || start >= end) {
    console.error(`Invalid boundaries for ${sectionName}: start=${start}, end=${end}, contentLength=${templateContent.length}`);
    return null;
  }

  const sectionJSON = templateContent.slice(start, end);
  return { startIndex: start, endIndex: end, sectionJSON };
}

// Generate filled JSON for a section using AI
async function generateFilledSectionJSON(
  sectionJSON: any[],
  sectionName: string,
  country: string,
  databaseContent?: string
): Promise<{ filledJSON: any[]; sources: string[] }> {
  const startTime = Date.now();
  
  const sectionJSONStr = JSON.stringify(sectionJSON, null, 2);
  
  // Build prompt for AI - simplified and focused structure
  let prompt = `Here's the JSON you need to fill out:

${sectionJSONStr}

${databaseContent ? `Here's data from the database on ${country} for the "${sectionName}" section:

${databaseContent.substring(0, 10000)}${databaseContent.length > 10000 ? '\n\n[... database content truncated for length ...]' : ''}` : ''}

Your job is to fill out the "${sectionName}" section accurately for ${country}.

${databaseContent ? `- Use the database data provided above as your PRIMARY source
- Fill in any gaps or missing information using your knowledge of ${country} and climate transparency frameworks` : `- Generate comprehensive content based on your knowledge of ${country} and climate transparency frameworks`}
- Fill in all placeholders (like "[…]", "[XXX words]", "PROMPT:", "[….]", etc.) with actual content
- Fill out ALL tables completely - add rows with actual data, fill in all table cells
- Replace "{Country}" or "[Country]" with "${country}"
- Maintain ALL formatting, structure, tables, headings, and JSON structure exactly as provided
- Keep all "STANDARD TEXT TO BE INCLUDED" and "STANDARD TEXT TO BE INCLUDED END" sections exactly as-is
- Preserve all table structure (tableRow, tableHeader, colspan, rowspan, etc.)
- Do NOT remove any nodes - only replace placeholder text content

IMPORTANT: Accumulate sources (URLs, document names, etc.) as you generate content. Append a new paragraph at the bottom of the section with the sources in this format:
"Sources: [source1, source2, source3]"

CRITICAL: Return ONLY the filled ProseMirror JSON array. The response must be VALID JSON that can be parsed directly. 

IMPORTANT JSON VALIDITY REQUIREMENTS:
- All strings must use double quotes (")
- Escape all double quotes inside strings with backslash (\")
- Escape all backslashes with double backslash (\\)
- Escape newlines in strings as \\n
- No trailing commas
- All property names must be in double quotes
- Ensure proper closing brackets and braces

Do not wrap in markdown code blocks. Do not add explanations. Return the complete JSON array starting with "[" and ending with "]".`;

  // Retry logic with exponential backoff for rate limits
  const maxRetries = 5;
  let lastError: any = null;
  
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      // Use gpt-4o-mini for better rate limits and lower cost
      // It's sufficient for JSON structure filling tasks
      const result = await generateText({
        model: openai('gpt-4o-mini'),
        prompt,
        temperature: 0.3,
      });
      
      // Extract JSON from response (handle cases where AI wraps it in markdown)
      let jsonStr = result.text.trim();
      
      // Remove markdown code blocks if present
      jsonStr = jsonStr.replace(/^```json\n?/gm, '').replace(/^```\n?/gm, '').replace(/```$/gm, '');
      jsonStr = jsonStr.trim();

      // Try to parse the JSON
      let filledJSON: any[];
      try {
        filledJSON = JSON.parse(jsonStr);
      } catch (parseError: any) {
        // Try to extract JSON array from the response
        const jsonMatch = jsonStr.match(/\[[\s\S]*\]/);
        let jsonToRepair = jsonMatch ? jsonMatch[0] : jsonStr;
        
        try {
          // Try parsing the extracted JSON
          filledJSON = JSON.parse(jsonToRepair);
        } catch (extractError: any) {
          try {
            // Use jsonrepair to fix common JSON syntax errors
            const repairedJson = jsonrepair(jsonToRepair);
            filledJSON = JSON.parse(repairedJson);
          } catch (repairError: any) {
            console.error(`[${sectionName}] ✗ JSON repair failed: ${repairError.message}`);
            throw new Error(`Could not parse or repair JSON from AI response: ${repairError.message}`);
          }
        }
      }

      // Extract sources from the response if available
      const sources: string[] = [];
      const sourcesMatch = result.text.match(/Sources?:?\s*\[([^\]]+)\]/i);
      if (sourcesMatch) {
        try {
          const sourcesStr = '[' + sourcesMatch[1] + ']';
          sources.push(...JSON.parse(sourcesStr));
        } catch (e) {
          // Ignore source parsing errors
        }
      }

      return { filledJSON, sources };
    } catch (error: any) {
      lastError = error;
      const errorType = error?.constructor?.name || 'Unknown';
      const errorMessage = error?.message || String(error);
      
      console.error(`[${sectionName}] ✗ Error on attempt ${attempt + 1}/${maxRetries}:`, {
        errorType,
        errorMessage: errorMessage.substring(0, 200),
        hasCause: !!error?.cause,
        causeMessage: error?.cause?.message?.substring(0, 200),
      });
      
      // Check if it's a rate limit error
      const isRateLimit = errorMessage?.includes('rate limit') || 
                         errorMessage?.includes('Rate limit') ||
                         error?.cause?.message?.includes('rate limit') ||
                         errorMessage?.includes('TPM') ||
                         errorMessage?.includes('RPM');
      
      if (isRateLimit && attempt < maxRetries - 1) {
        // Exponential backoff: wait 2^attempt seconds (with max 30 seconds)
        const waitTime = Math.min(Math.pow(2, attempt) * 1000, 30000);
        await new Promise(resolve => setTimeout(resolve, waitTime));
        continue;
      }
      
      // Check if it's a timeout error
      const isTimeout = errorMessage?.includes('timeout') || 
                       errorMessage?.includes('Timeout') ||
                       errorMessage?.includes('ETIMEDOUT');
      
      if (isTimeout && attempt < maxRetries - 1) {
        const waitTime = Math.min(Math.pow(2, attempt) * 1000, 30000);
        await new Promise(resolve => setTimeout(resolve, waitTime));
        continue;
      }
      
      // If not rate limit/timeout or max retries reached, fallback
      if (attempt === maxRetries - 1) {
        console.error(`[${sectionName}] ✗ Max retries reached: ${errorMessage.substring(0, 200)}`);
        // Fallback: return original JSON with basic replacements
        return { filledJSON: sectionJSON, sources: [] };
      }
      
      // For other errors, retry with backoff
      const waitTime = Math.min(Math.pow(2, attempt) * 1000, 10000);
      await new Promise(resolve => setTimeout(resolve, waitTime));
      continue;
    }
  }
  
  // Should never reach here, but TypeScript needs it
  console.error(`[${sectionName}] ✗ generateFilledSectionJSON failed after all retries:`, lastError?.message || 'Unknown error');
  return { filledJSON: sectionJSON, sources: [] };
}

// Replace [Country] placeholders in JSON recursively
function replaceCountryPlaceholders(node: any, country: string): any {
  if (!node) return node;
  
  const newNode = JSON.parse(JSON.stringify(node));
  
  if (newNode.type === 'text' && newNode.text) {
    newNode.text = newNode.text.replace(/\[Country\]|\{Country\}/g, country);
  }
  
  if (newNode.content && Array.isArray(newNode.content)) {
    newNode.content = newNode.content.map((child: any) => replaceCountryPlaceholders(child, country));
  }
  
  return newNode;
}

// Section subagent: Extracts JSON chunk, fills it with AI, returns filled JSON
async function processSectionSubagent(
  sectionName: string,
  country: string,
  countryData: any,
  templateContent: any[]
): Promise<{ sectionName: string; filledJSON: any[] | null; source: 'database' | 'ai'; sources?: string[] }> {
  // Step 1: Extract section JSON from template
  const sectionExtraction = extractSectionJSON(templateContent, sectionName);
  if (!sectionExtraction) {
    return { sectionName, filledJSON: null, source: 'ai', sources: [] };
  }

  const { sectionJSON } = sectionExtraction;
  
  // Step 2: Check database for this section
  let dbContent: string | null = null;
  let hasDatabaseData = false;
  
  if (countryData?.sections) {
    const sectionsData = countryData.sections as { sections?: Array<{ name: string; documents: Array<{ doc_type: string; extracted_text: string }> }> } | null;
    const sectionsArray = sectionsData?.sections || [];
    const section = sectionsArray.find(s => s.name === sectionName);
    
    if (section && section.documents && section.documents.length > 0) {
      dbContent = formatSectionContent(section);
      if (dbContent && dbContent.trim().length > 0) {
        hasDatabaseData = true;
      }
    }
  }
  
  // Step 3: Generate filled JSON using AI
  try {
    const { filledJSON, sources } = await generateFilledSectionJSON(
      sectionJSON,
      sectionName,
      country,
      dbContent || undefined
    );
    
    // Replace country placeholders
    const finalJSON = filledJSON.map((node: any) => replaceCountryPlaceholders(node, country));
    
    return { 
      sectionName, 
      filledJSON: finalJSON,
      source: hasDatabaseData ? 'database' : 'ai', 
      sources: sources || [] 
    };
  } catch (error) {
    console.error(`[Subagent: ${sectionName}] Error generating filled JSON:`, error);
    // Fallback: return original JSON with country replacements
    const fallbackJSON = sectionJSON.map((node: any) => replaceCountryPlaceholders(node, country));
    return { sectionName, filledJSON: fallbackJSON, source: hasDatabaseData ? 'database' : 'ai', sources: [] };
  }
}

// Generate PIF document
async function generateNewPIF(country: string, countryData: any = null) {
  // Normalize country name
  const normalizedCountry = country.charAt(0).toUpperCase() + country.slice(1);
  
  // Load the template JSON
  const templatePath = path.join(process.cwd(), 'public', 'pif-template.json');
  let template: any;
  
  try {
    const templateContent = fs.readFileSync(templatePath, 'utf-8');
    template = JSON.parse(templateContent);
  } catch (error) {
    console.error('[PIF Generation] Error loading template:', error);
    throw new Error('Failed to load PIF template');
  }

  // Get the content array from template
  const templateContent = template.content || [];
  if (!Array.isArray(templateContent)) {
    throw new Error('Template content is not an array');
  }

  // Step 1: Process sections sequentially to avoid rate limits
  // Process in batches of 2 to balance speed and rate limits
  console.log(`[PIF Generation] Sending call to 10 subagents to begin work...`);
  const BATCH_SIZE = 2;
  const sectionResults: Array<{ sectionName: string; filledJSON: any[] | null; source: 'database' | 'ai'; sources?: string[] }> = [];
  
  for (let i = 0; i < SECTION_NAMES.length; i += BATCH_SIZE) {
    const batch = SECTION_NAMES.slice(i, i + BATCH_SIZE);
    
    const batchPromises = batch.map(sectionName => 
      processSectionSubagent(sectionName, normalizedCountry, countryData, templateContent)
    );
    
    const batchResults = await Promise.all(batchPromises);
    sectionResults.push(...batchResults);
    
    // Small delay between batches to avoid rate limits
    if (i + BATCH_SIZE < SECTION_NAMES.length) {
      await new Promise(resolve => setTimeout(resolve, 1000)); // 1 second delay
    }
  }
  
  console.log(`[PIF Generation] ✓ All 10 subagents have returned`);
  
  // Build section replacement map and log entries
  const sectionReplacements: Map<string, { filledJSON: any[]; startIndex: number; endIndex: number }> = new Map();
  const dbSections: string[] = [];
  const aiSections: string[] = [];
  const logEntries: Array<{ sectionName: string; source: 'database' | 'ai'; sources?: string[] }> = [];
  
  sectionResults.forEach(({ sectionName, filledJSON, source, sources }) => {
    if (filledJSON && filledJSON.length > 0) {
      const extraction = extractSectionJSON(templateContent, sectionName);
      if (extraction) {
        sectionReplacements.set(sectionName, {
          filledJSON,
          startIndex: extraction.startIndex,
          endIndex: extraction.endIndex,
        });
        
        if (source === 'database') {
          dbSections.push(sectionName);
        } else {
          aiSections.push(sectionName);
        }
        logEntries.push({ sectionName, source, sources });
      }
    }
  });

  // Step 2: Replace sections in template with filled JSON
  // Sort replacements by startIndex in reverse order to avoid index shifting issues
  const sortedReplacements = Array.from(sectionReplacements.entries())
    .map(([sectionName, data]) => ({
      sectionName,
      ...data,
    }))
    .sort((a, b) => b.startIndex - a.startIndex); // Reverse order
  
  // Create new content array with replacements
  let filledContent = [...templateContent];
  
  for (const replacement of sortedReplacements) {
    const { filledJSON, startIndex, endIndex } = replacement;
    
    // Replace the section
    filledContent = [
      ...filledContent.slice(0, startIndex),
      ...filledJSON,
      ...filledContent.slice(endIndex),
    ];
  }
  
  // Replace [Country] placeholders in remaining content
  filledContent = filledContent.map((node: any) => replaceCountryPlaceholders(node, normalizedCountry));
  
  // Create filled template
  const filledTemplate = {
    ...template,
    content: filledContent,
  };

  // Step 3: Convert to document format
  const { convertProseMirrorToDocument } = await import('@/lib/document-converter');
  const document = convertProseMirrorToDocument(filledTemplate);
  
  // Update title with country name
  document.title = `GEF-8 PROJECT IDENTIFICATION FORM (PIF) - ${normalizedCountry}`;

  return { document, logEntries };
}

export async function POST(req: Request) {
  try {
    const formData = await req.formData();
    const country = formData.get('country') as string;

    if (!country || !country.trim()) {
      return Response.json({ error: 'Country name is required' }, { status: 400 });
    }

    const normalizedCountry = country.trim().charAt(0).toUpperCase() + country.trim().slice(1);

    // Get country data (files should already be processed via /api/process-files)
    console.log(`[PIF Generation] Fetching data from database for ${normalizedCountry}...`);
    let countryData = null;
    const { country: existingCountry, error: countryError } = await getCountryByName(normalizedCountry);
    
    if (countryError || !existingCountry) {
      // Create new country record if it doesn't exist
      const { data: newCountry, error: createError } = await supabase
        .from('countries')
        .insert({
          name: normalizedCountry,
          sections: { sections: [] }
        })
        .select()
        .single();
      
      if (!createError && newCountry) {
        countryData = newCountry;
        console.log(`[PIF Generation] Database hit: NO - Created new country record (no data found)`);
      } else {
        // If creation fails, continue with null countryData (will generate from web sources only)
        console.log(`[PIF Generation] Database hit: NO - Could not create country record (will generate from web sources)`);
      }
    } else {
      countryData = existingCountry;
      // Check if country has any data
      const sectionsData = countryData.sections as { sections?: Array<{ name: string; documents: Array<any> }> } | null;
      const sectionsArray = sectionsData?.sections || [];
      const hasAnyData = sectionsArray.some(s => s.documents && s.documents.length > 0);
      
      if (hasAnyData) {
        console.log(`[PIF Generation] Database hit: YES - Found data for ${normalizedCountry}`);
      } else {
        console.log(`[PIF Generation] Database hit: NO - No data found for ${normalizedCountry} (will generate from web sources)`);
      }
    }

    // Generate PIF document using 10 subagents
    // Each subagent checks database first, then generates with AI if needed
    const { document, logEntries } = await generateNewPIF(normalizedCountry, countryData);

    // Build log entries for response
    const responseLogEntries = [];
    
    // Add database hit entry
    if (countryData && countryData.sections) {
      const sectionsData = countryData.sections as { sections?: Array<{ name: string; documents: Array<any> }> } | null;
      const sectionsArray = sectionsData?.sections || [];
      const hasAnyData = sectionsArray.some(s => s.documents && s.documents.length > 0);
      
      if (hasAnyData) {
        responseLogEntries.push({
          id: `db-hit-${Date.now()}`,
          timestamp: new Date().toISOString(),
          type: 'success',
          message: `Database hit found for ${normalizedCountry}`,
          databaseData: countryData, // Include full database data
        });
      } else {
        responseLogEntries.push({
          id: `db-miss-${Date.now()}`,
          timestamp: new Date().toISOString(),
          type: 'info',
          message: `No database data found for ${normalizedCountry}. Generating from online sources.`,
        });
      }
    } else {
      responseLogEntries.push({
        id: `db-miss-${Date.now()}`,
        timestamp: new Date().toISOString(),
        type: 'info',
        message: `No database data found for ${normalizedCountry}. Generating from online sources.`,
      });
    }
    
    // Add section entries
    logEntries.forEach((entry, idx) => {
      responseLogEntries.push({
        id: `section-${idx}-${Date.now()}`,
        timestamp: new Date().toISOString(),
        type: 'section',
        message: entry.source === 'database' 
          ? `✓ Found in database` 
          : `Generating from online sources`,
        section: entry.sectionName,
        source: entry.source,
        sources: entry.sources || [],
      });
    });
    
    // Add completion entry
    responseLogEntries.push({
      id: `complete-${Date.now()}`,
      timestamp: new Date().toISOString(),
      type: 'success',
      message: `PIF generation complete for ${normalizedCountry}`,
    });

    console.log(`[PIF Generation] ✓ PIF generation complete for ${normalizedCountry}`);

    return Response.json({
      document,
      country: normalizedCountry,
      hasDatabaseData: countryData && countryData.sections ? true : false,
      logEntries: responseLogEntries,
    });

  } catch (error) {
    console.error('[PIF Generation] ✗ Error generating PIF:', error);
    return Response.json(
      { error: error instanceof Error ? error.message : 'Failed to generate PIF' },
      { status: 500 }
    );
  }
}

